1. Can you think of why we use `fork/execvp` instead of just calling `execvp` directly? What value do you think the `fork` provides?

    > **Answer**:  Using fork creates a new child process so that execvp replaces only the child. This lets the
	 > parent (shell) continue running and manage multiple commands without terminating itself.

2. What happens if the fork() system call fails? How does your implementation handle this scenario?

    > **Answer**:  If fork() fails (returns a negative value), an error message is printed and an error code is
	 > returned. This prevents further command execution and signals the failure.

3. How does execvp() find the command to execute? What system environment variable plays a role in this process?

    > **Answer**:  execvp() searches for the command in the directories listed in the PATH environment variable. PATH
	 > is essential for locating executables.

4. What is the purpose of calling wait() in the parent process after forking? What would happen if we didnâ€™t call it?

    > **Answer**:  wait() forces the parent process to pause until the child terminates, allowing it to retrieve the
	 > child's exit status. Without wait(), the parent might continue immediately, potentially leaving zombie
	 > processes and missing the command's result.

5. In the referenced demo code we used WEXITSTATUS(). What information does this provide, and why is it important?

    > **Answer**:  It extracts the exit code from the status returned by wait(). It tells us whether the child
	 > process succeeded or failed. This is important for error handling and feedback.

6. Describe how your implementation of build_cmd_buff() handles quoted arguments. Why is this necessary?

    > **Answer**:  My implementation detects double quotes and treats the enclosed text as a single token. This is
	 > necessary so that arguments with spaces aren't split incorrectly.

7. What changes did you make to your parsing logic compared to the previous assignment? Were there any unexpected challenges in refactoring your old code?

    > **Answer**:  I improved the parser to skip redundant whitespace and correctly handle quoted strings. The
	 > challenge was managing pointer arithmetic and ensuring quotes were balanced while preserving intended spaces.

8. For this quesiton, you need to do some research on Linux signals. You can use [this google search](https://www.google.com/search?q=Linux+signals+overview+site%3Aman7.org+OR+site%3Alinux.die.net+OR+site%3Atldp.org&oq=Linux+signals+overview+site%3Aman7.org+OR+site%3Alinux.die.net+OR+site%3Atldp.org&gs_lcrp=EgZjaHJvbWUyBggAEEUYOdIBBzc2MGowajeoAgCwAgA&sourceid=chrome&ie=UTF-8) to get started.

- What is the purpose of signals in a Linux system, and how do they differ from other forms of interprocess communication (IPC)?

    > **Answer**:  The purpose is the signals provide asynchronous notifications to processes about events (like
	 > interrupts or termination requests). Unlike other IPC methods that exchange data, signals merely notify
	 > processes to take specific actions.

- Find and describe three commonly used signals (e.g., SIGKILL, SIGTERM, SIGINT). What are their typical use cases?

    > **Answer**:  SIGKILL: Immediately terminates a process and cannot be caught or ignored. SIGTERM: Requests
	 > graceful termination, allowing cleanup before shutting down. SIGINT: Typically generated by Ctrl+C. It
	 > interrupts a process and can be caught to perform custom shutdown actions.

- What happens when a process receives SIGSTOP? Can it be caught or ignored like SIGINT? Why or why not?

    > **Answer**:  SIGSTOP pauses a process immediately. It cannot be caught, blocked, or ignored because it must
	 > always be honored by the kernel to ensure processes can be reliably stopped.
